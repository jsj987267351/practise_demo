package day2023_06_29.demo3;

/**
 * @author ：大爆炸
 * @version 1.0
 * @description 给定一个二叉树，我们在树的节点上安装摄像头。
 * <p>
 * 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
 * <p>
 * 计算监控树的所有节点所需的最小摄像头数量。
 * https://leetcode.cn/problems/binary-tree-cameras/
 * @date 2023/6/29 13:58
 */
public class demo3 {
    int res = 0;

    //    解题思路: 后续遍历，想要摄像头最小的方法就是在叶子节点的父节点放置摄像头，之所以不从根节点开始遍历，是因为叶子节点一定比根节点多，摄像头利用最大化
//    叶子节点的父节点放置摄像头后，父节点的父节点就也被覆盖了，在往上的父节点的父节点再放摄像头即可，即隔两层几点在放摄像头利用最大化
//    定义3中状态，  0：无覆盖  1：有摄像头  2：有覆盖
    public int minCameraCover(TreeNode root) {
//        特殊情况，有可能父节点的孩子节点为有覆盖状态，父节点会直接定义为有覆盖状态，在往上无法遍历，所以父节点会被无法覆盖，需要特殊判断。
        if (help(root) == 0) {
            res++;
        }
        return res;
    }

    public int help(TreeNode root) {
//        初始叶子节点的孩子节点（即空节点）要被设置为已覆盖状态，因为如果设置为无覆盖状态的话  叶子节点就要安装摄像头，如果设置为有摄像头的话，叶子节点就会被定义为有覆盖
//        那么叶子节点的父节点就不会安装摄像头了，违背算法
        if (root == null) {
            return 2;
        }
//        后续遍历获得两个孩子的状态
        int left = help(root.left);
        int right = help(root.right);
//        第一种情况：如果两个孩子都是有覆盖状态的话，那么父节点就要定义为无覆盖
        if (left == 2 && right == 2) {
            return 0;
        }
//        第二种情况：如果左右节点有一个为无覆盖状态的话，那么父节点需要安装摄像头
        if (left == 0 || right == 0) {
            res++;
            return 1;
        }
//        第三种情况：如果左右节点有一个已经安装摄像头了的话，那么该节点就被覆盖了
        if (left == 1 || right == 1) {
            return 2;
        }
//        注意：第二种和第三种情况不能颠倒，因为如果左右节点为0和1，即状态二和状态三都满足，但这种情况该节点是需要安装摄像头的，所以需要将第二种情况放前面判断
//        不会走到这，上面三种情况已经包含了所有情况
        return -1;
    }
}

